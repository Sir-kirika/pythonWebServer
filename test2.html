<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebSocket JSON Table</title>
  <style>
    body {
      font-family: monospace;
      background: #1e1e1e;
      color: #dcdcdc;
      padding: 20px;
    }
    table {
      border-collapse: collapse;
      margin-top: 20px;
      width: 100%;
    }
    th, td {
      border: 1px solid #444;
      padding: 4px 8px;
      text-align: center;
    }
    th {
      background: #333;
    }
    .clrRed { background: #b22222; color: #fff; }
    .clrGreen { background: #228b22; color: #fff; }
    .clrSteelBlue { background: #4682b4; color: #fff; }
    #log {
      max-height: 60vh;
      overflow-y: auto;
      background: #252526;
      padding: 10px;
      border-radius: 6px;
      white-space: pre-wrap;
    }
    .error { color: #f44747; }
    .connect { color: #4ec9b0; }
    .data { color: #dcdcaa; }
  </style>
</head>
<body>
  <h2>WebSocket JSON Table</h2>
  <div id="log"></div>
  <table id="dataTable"></table>

  <script>
    const wsUrl = "wss://localhost:8443/ws?token=supersecret123";
    const logDiv = document.getElementById("log");
    const table = document.getElementById("dataTable");

    function log(msg, cls="") {
      const el = document.createElement("pre");
      if (cls) el.classList.add(cls);
      el.textContent = msg;
      logDiv.appendChild(el);
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function renderTable(data) {
        const symbols = data.symbols;
        if (!symbols || !Array.isArray(symbols) || symbols.length === 0) {
            console.warn("No symbol data to display");
            table.innerHTML = "<tr><td>No data</td></tr>";
            return;
        }

        // Collect timeframes in order as they appear in JSON
        const timeframesSet = new Set();
        symbols.forEach(sym => {
            sym.TF_data.forEach(tfObj => {
                Object.keys(tfObj).forEach(k => {
                    if (k !== "cell_color" && !timeframesSet.has(k)) {
                        timeframesSet.add(k);
                    }
                });
            });
        });

        const tfList = Array.from(timeframesSet); // preserve JSON order

        // Clear previous table
        table.innerHTML = "";

        // Header row
        const headerRow = table.insertRow();
        const pairTh = document.createElement("th");
        pairTh.textContent = "Pair";
        headerRow.appendChild(pairTh);
        tfList.forEach(tf => {
            const th = document.createElement("th");
            th.textContent = tf;
            headerRow.appendChild(th);
        });
        const sumTh = document.createElement("th");
        sumTh.textContent = "Sum";
        headerRow.appendChild(sumTh);

        // Data rows
        symbols.forEach(sym => {
            const row = table.insertRow();
            const pairCell = row.insertCell();
            pairCell.textContent = sym.pair;

            tfList.forEach(tf => {
                const cell = row.insertCell();
                const tfObj = sym.TF_data.find(x => x[tf] !== undefined);
                if (tfObj) {
                    cell.textContent = tfObj[tf].toFixed(4);
                    if (tfObj.cell_color) cell.classList.add(tfObj.cell_color);
                } else {
                    cell.textContent = "-";
                }
            });

            const sumCell = row.insertCell();
            sumCell.textContent = (sym.sum !== undefined ? sym.sum.toFixed(4) : "-");
            if (sym.sum_cell_color) sumCell.classList.add(sym.sum_cell_color);
        });
    }

    const ws = new WebSocket(wsUrl);

    ws.onopen = () => log("[CONNECTED]", "connect");
    ws.onmessage = (event) => {
      try {
        const obj = JSON.parse(event.data);

        if (!obj.symbols) {
          log("⚠️ JSON missing 'symbols' key. Full JSON:\n" + JSON.stringify(obj, null, 2), "error");
          table.innerHTML = "<tr><td>No data</td></tr>";
          return;
        }

        renderTable(obj);
      } catch (e) {
        log("[ERROR parsing JSON] " + e.message + "\nRAW DATA: " + event.data, "error");
      }
    };
    ws.onclose = () => log("[DISCONNECTED]", "error");
    ws.onerror = (err) => log("[ERROR] " + JSON.stringify(err), "error");
  </script>
</body>
</html>
